/**
 * TupleSpace implementation
 *
 * User: wessel, giemza
 * Date: 09.02.12
 * Time: 20:05
 */

/**
 * Imports
 */
var Utils = require('./utils');
var Class = require('./class');
var Version = require('./version')
var Connector = require('./socketconnector');
var Tuple = require('./tuple');
var Space = require('./space');

/**
 * Creates a new TupleSpace
 * @param options
 * @param {String} options.host The host of the web socket server
 * @param {String} options.port The port of the web socket server
 * @param {String} options.endpoint The endpoint of the web socket server
 * @param {String} options.user The username to connect with
 * @param {String} options.password The password to connect with
 * @param {String} options.space The space
 * @param {Object} options.connector The connector object (Connector by default)
 * @param {Function} options.onCallback Called if a message was sent to the client without a request
 * @param {Function} options.onError Called if an error occurs
 * @class
 */
module.exports = Class(/** @lends TupleSpace */{

    'constructor': function(options, readyCallback) {
        var self = this;
        options = options || {host: 'localhost', port: 2525, endpoint: 'ws-json', space: 'defaultspace'};

        this.space = null;
        this.connected = false;
        this.callbacks = [];
        Utils.setDebugEnabled(options.debug || false);

        // Setup messenger, if no connector object was passed create a Connector
        this.connector = options.connector || new Connector({
            host: options.host || null,
            port: options.port || null,
            debug: options.debug || false,
            onCallback: function(data) {
                // This method will be called if a message was sent
                // to the client without a request (e.g. for server callbacks)
                self.handleCallback(data);
				},
            onError: function(msg) {
                if(typeof options.onError == 'function') options.onError.call(this, msg);
            }
        });

        // Connect to tuplespace
        this.connect(
            options.user || 'sqlspaces',
            options.password || 'sqlspaces',
            options.space || 'defaultspace',
            // Called when the connected
            function() {
                if(typeof readyCallback == 'function') readyCallback.call(this);
            }
        );
    },

    'private': {

        /**
         * Handles the callback
         * @private
         */
        handleCallback: function(data) {
            var id = data.seq;
            if(typeof this.callbacks[id] !== 'undefined') {

                if(typeof data.after.tuple !== 'undefined') {
                    var tuple = new Tuple();
                    tuple.fromJSON(data.after.tuple);
                    data.after.tuple = tuple;
                }

                if(typeof data.before.tuple !== 'undefined') {
                    var tuple = new Tuple();
                    tuple.fromJSON(data.before.tuple);
                    data.before.tuple = tuple;
                }

                this.callbacks[id].call(this, data);
            }
        },

        /**
         * Connect to the tuple space
         * @param {String} user The username to connect with
         * @param {String} password The password to connect with
         * @param {String} space The space
         * @private
         */
        connect: function(user, password, space, callback) {
            var self = this;

            this.send({
                connect: {
                    'spaces': {'space': {'textcontent': space}},
                    'user': {'textcontent': user},
                    'password': {'textcontent': password}
                }
            }, function(data) {
                // Check if a tuple array was passed
                if(data.response && typeof data.response.tuples.length) {
                    var tuple = new Tuple();

                    // Create a new tuple from the response
                    tuple.fromJSON(data.response.tuples[0]);

                    // Create space from tuple
                    self.space = new Space(
                        tuple.getField(0).getValue(), // name
                        tuple.getField(1).getValue(), // id
                        new Version(
                            tuple.getField(2).getValue(),	// version
                            tuple.getField(3).getValue(),	// major
                            tuple.getField(4).getValue(),	// minor
                            tuple.getField(5).getValue(),	// branch
                            tuple.getField(6).getValue(),	// name
                            tuple.getField(7).getValue(),	// group
                            tuple.getField(8).getValue(),	// lockedByUser
                            tuple.getField(9).getValue()	// shared
                        )
                    );
                    self.connected = true;
                    Utils.log('Connected to tuple space');

                    // Call the callback
                    if(typeof callback == 'function') callback.call(this);
                } else {
                    // Invalid response from server
                    throw new Error(data);
                }
            });
        },

        /**
         * Sends a message to the connector
         * @param {String} message The message to be sent
         * @param {Function} callback The function to be called when a response arrives
         * @private
         */
        send: function(message, callback, id) {
            // Send the request to the connector
            this.connector.send(message, callback, id || null);
        },

        /**
         * @private
         */
        query: function(type, tuple, callback, options) {
            var self = this;
            options = options || {};

            this.tryTupleSpace(function() {
                if(tuple instanceof Tuple) {
                    self.send({
                        'query': {
                            'type': type,
                            'randomize': options.randomize || 'true',
                            'returning': options.returning || 'true',
                            'windowsize': options.windowsize || null,
                            'space': options.spaceId || self.space.getID(),
                            'tuple': tuple.toJSON()
                        }
                    }, function(data) {
                        // Call the callback and pass the data
                        if(typeof callback == 'function') callback.call(this, data);
                    // Send the id (for iterative queries)
                    }, options.id || null);
                } else {
                    throw new Error('Tuple must be an instance of Tuple');
                }
            });
        },

        /**
         * @private
         */
        getVersions: function(callback, options) {
            var self = this;
            options = options || {};

            this.tryTupleSpace(function() {
                self.send({
                    'get-versions': {
                        'spaceid': self.space.getID(),
                        'user': options.user || 'false',
                        'all': options.all || 'true'
                    }
                }, function(data) {
                    if(data.response.tuples && data.response.tuples.length) {
                        var versions = [];
                        for(var i = 0, il = data.response.tuples.length; i < il; i++) {
                            // Create a version from the tuple, created from response
                            var t = new Tuple();
                            var v = new Version();
                            t.fromJSON(data.response.tuples[i]);

                            versions.push(new Version(
                                t.getField(0).getValue(),	// version
                                t.getField(1).getValue(),	// major
                                t.getField(2).getValue(),	// minor
                                t.getField(3).getValue(),	// branch
                                t.getField(4).getValue(),	// name
                                t.getField(5).getValue(),	// group
                                t.getField(6).getValue(),	// lockedByUser
                                t.getField(7).getValue()	// shared
                            ));
                        }
                        if(typeof callback == 'function') callback.call(this, versions);
                    }
                })
            });
        },

        /**
         * @private
         */
        setVersion: function(callback, options) {
            var self = this;
            options = options || {};

            this.tryTupleSpace(function() {
                var currentVersion = self.space.getVersion();
                self.send({
                    'set-version' : {
                        'old-versionsid': options['old-versionsid'] || currentVersion.getVersion(),
                        'major': options['major'] || currentVersion.getMajor(),
                        'minor': options['minor'] || currentVersion.getMinor(),
                        'branch': options['branch'] || currentVersion.getBranch(),
                        'name': options['name'] || currentVersion.getName(),
                        'group': options['group'] || currentVersion.getGroup(),
                        'new-version': options['new-version'] || 'false',
                        'spaceid': options['spaceid'] || self.space.getID()
                    }
                }, function (data) {
                    // Check if a tuple array was passed
                    if(data.response.tuples && data.response.tuples.length) {
                        // Create a version from the tuple, created from response
                        var t = new Tuple();
                        t.fromJSON(data.response.tuples[0]);
                        var version = new Version(
                            t.getField(0).getValue(),	// version
                            t.getField(1).getValue(),	// major
                            t.getField(2).getValue(),	// minor
                            t.getField(3).getValue(),	// branch
                            t.getField(4).getValue(),	// name
                            t.getField(5).getValue(),	// group
                            t.getField(6).getValue()	// lockedByUser
                        );
                        self.space.version = version;
                        if(typeof callback == 'function') callback.call(this, version);
                    }
                });
            });
        },

        /**
         * @private
         */
        transaction: function(callback, options) {
            var self = this;
            options = options || {};

            this.tryTupleSpace(function() {
                self.send({
                    'transaction': {
                        "type": options.type || null
                    }
                }, function(data) {
                    if(data.response) {
                        if(typeof callback == 'function') callback.call(this,
                            data.response.type === 'ok'
                        );
                    }
                })
            });
        },

        /**
         * @private
         */
        tryTupleSpace: function(callback) {
            var self = this, interval, iterations = 0;

            if(this.connected == true) {
                callback.call();
            } else {
                interval = setInterval(function() {
                    iterations++;
                    Utils.log('Wait for tuplespace (' + iterations + ')');

                    if(self.connected == true) {
                        clearInterval(interval);
                        callback.call();
                    } else if (iterations == 10) {
                        clearInterval(interval);
                        Utils.log('TupleSpace wasn\'t able to react after 10 tries');
                    }
                }, 500);
            }
        },

        /**
         * @private
         */
        parseTuple: function(data) {
            var tuple = null;
            if(data.response.tuples) {
                // Create a new tuple from the response
                tuple = new Tuple();
                tuple.fromJSON(data.response.tuples[0]);
            }
            return tuple;
        },

        /**
         * @private
         */
        parseTupleArray: function(data) {
            var tuples = null;
            if(data.response.tuples) {
                tuples = [];
                for(var i = 0, il = data.response.tuples.length; i < il; i++) {
                    var t = new Tuple();
                    t.fromJSON(data.response.tuples[i]);
                    tuples.push(t);
                }
            }
            return tuples;
        }
    },

    'public': {

        /**
         * Writes given Tuple into the currently connected Space
         * @param {Tuple} tuple The tuple
         * @param {Function} callback The method to be called when a response arrives
         * @public
         */
        write: function(tuple, callback) {
            var self = this;

            this.tryTupleSpace(function() {
                if(tuple instanceof Tuple) {
                    self.send({
                        'write': {
                            'space': self.space.getID(),
                            'tuple': tuple.toJSON()
                        }
                    }, function(data) {
                        // Check if a tuple array was passed
                        if(data.response && typeof data.response.tuples.length) {
                            var tuple = new Tuple();

                            // Create a new tuple from the response
                            tuple.fromJSON(data.response.tuples[0]);

                            // Call the callback and pass the tuple id
                            if(typeof callback == 'function') callback.call(this,
                                // Get the first field, which contains the id of the written tuple
                                tuple.getField(0).getValue()
                            );
                        } else {
                            // Invalid response from server
                            throw new Error(data);
                        }
                    })
                } else {
                    throw new Error('Tuple must be an instance of Tuple');
                }
            });
        },

        /**
         * Updates the given Tuple with the given TupleId in the currently connected Space.
         * @param tupleId the TupleId of the Tuple to be updated
         * @param {Tuple} tuple the new Tuple content
         * @param {Function} callback The method to be called when a response arrives
         */
        update: function(tupleId, tuple, callback) {
            var self = this;
            this.tryTupleSpace(function() {
                if(tuple instanceof Tuple) {
                    self.send({
                        'update': {
                            'tupleid': {'id': tupleId},
                            'tuple': tuple.toJSON()
                        }
                    }, function(data) {
                        if(typeof callback == 'function') callback.call(this,
                            data.response.type === 'ok'
                        );
                    });
                } else {
                    throw new Error('Tuple must be an instance of Tuple');
                }
            });
        },

        /**
         * Takes a Tuple (if any) matching given template.
         * @param {Tuple} tuple The tuple
         * @param {Function} callback The method to be called when a response arrives
         * @public
         */
        take: function(tuple, callback) {
            var self = this;
            this.query('take', tuple, function(data) {
                var tuple = self.parseTuple(data);
                if(typeof callback == 'function') callback.call(this, tuple);
            });
        },

        /**
         * Takes all Tuples matching given template.
         * @param {Tuple} tuple The tuple
         * @param {Function} callback The method to be called when a response arrives
         * @public
         */
        takeAll: function(tuple, callback) {
            var self = this;
            this.query('takeAll', tuple, function(data) {
                var tuples = self.parseTupleArray(data);
                if(typeof callback == 'function') callback.call(this, tuples);
            });
        },

        /**
         * Takes first Tuple matching given template.
         * @param {Tuple} tuple The tuple
         * @param {Function} callback The method to be called when a response arrives
         * @public
         */
        takeFirst: function(tuple, callback) {
            var self = this;
            this.query('take', tuple, function(data) {
                var tuple = self.parseTuple(data);
                if(typeof callback == 'function') callback.call(this, tuple);
            }, {randomize: 'false'});
        },

        /**
         * Takes Tuple having given TupleID.
         * @param {Number} id The tuple id
         * @param {Function} callback The method to be called when a response arrives
         * @public
         */
        takeTupleById: function(id, callback) {
            var self = this;
            var tuple = new Tuple([], id);
            this.query('take', tuple, function(data) {
                var tuple = self.parseTuple(data);
                if(typeof callback == 'function') callback.call(this, tuple);
            }, {randomize: 'false'});
        },

        /**
         * Waits a given amount of time to take Tuple matching given template.
         * @param {Tuple} tuple The tuple
         * @param {Inteher} timeout Millisecond to wait
         * @param {Function} callback The method to be called when a response arrives
         * @public
         */
        waitToTake: function(tuple, timeout, callback) {
            // TODO
        },

        /**
         * Waits a given amount of time to take the first Tuple matching given template.
         * @param {Tuple} tuple The tuple
         * @param {Inteher} timeout Millisecond to wait
         * @param {Function} callback The method to be called when a response arrives
         * @public
         */
        waitToTakeFirst: function(tuple, timeout, callback) {
            // TODO
        },

        /**
         * Reads a Tuple matching passed tuple from database.
         * @param {Tuple} tuple The tuple
         * @param {Function} callback The method to be called when a response arrives
         * @public
         */
        read: function(tuple, callback) {
            var self = this;
            this.query('read', tuple, function(data) {
                var tuple = self.parseTuple(data);
                if(typeof callback == 'function') callback.call(this, tuple);
            });
        },

        /**
         * Reads all matching Tuples.
         * @param {Tuple} tuple The tuple
         * @param {Function} callback The method to be called when a response arrives
         * @param {Object} options object, may contain the following options
         *      windowsize Result limit per server query
         *      id Id of the server query
         * @public
         */
        readAll: function(tuple, callback, options) {
            var self = this;
            this.query('readAll', tuple, function(data) {
                var tuples = self.parseTupleArray(data);
                if(typeof callback == 'function') callback.call(this, tuples, data.response.id);
            }, options);
        },

        /**
         * Reads first matching Tuple.
         * @param {Tuple} tuple The tuple
         * @param {Function} callback The method to be called when a response arrives
         * @public
         */
        readFirst: function(tuple, callback) {
            var self = this;
            this.query('readFirst', tuple, function(data) {
                var tuple = self.parseTuple(data);
                if(typeof callback == 'function') callback.call(this, tuple);
            });
        },

        /**
         * Reads first matching Tuple.
         * @param {Tuple} tuple The tuple
         * @param {Function} callback The method to be called when a response arrives
         * @public
         */
        readTupleById: function(id, callback) {
            var self = this;
            var tuple = new Tuple([], id);
            this.query('read', tuple, function(data) {
                var tuple = self.parseTuple(data);
                if(typeof callback == 'function') callback.call(this, tuple);
            }, {randomize: 'false'});
        },

        /**
         * Deletes a random matching Tuple.
         * @param {Tuple} tuple The tuple template
         * @param {Function} callback The method to be called when a response arrives, receives true if successfully deleted
         */
        delete: function(tuple, callback) {
            this.query('take', tuple, function(data) {
                var tuple = new Tuple();
                // Create a new tuple from the response
                tuple.fromJSON(data.response.tuples[0]);
                // Create answer true/false
					var answer = tuple.getField(0).getValue() == '1';
                if(typeof callback == 'function') callback.call(this, answer);
            }, {returning: 'false'});
        },

        /**
         * Deletes all matching Tuple.
         * @param {Tuple} tuple The tuple template
         * @param {Function} callback The method to be called when a response arrives, receives {Number} of deleted tuples
         * @param {Number} spaceId The spaceId of the space to delete from
         */
        deleteAll: function(tuple, callback, spaceId) {
            this.query('takeAll', tuple, function(data) {
                var tuple = new Tuple();
                // Create a new tuple from the response
                tuple.fromJSON(data.response.tuples[0]);
                // Create answer true/false
                var numberOfDeteledTuples = tuple.getField(0).getValue();
                if(typeof callback == 'function') callback.call(this, numberOfDeteledTuples);
            }, {returning: 'false', spaceId: spaceId});
        },

        /**
         * Deletes the first matching Tuple.
         * @param {Tuple} tuple The tuple template
         * @param {Function} callback The method to be called when a response arrives, receives true if successfully deleted
         */
        deleteFirst: function(tuple, callback) {
            this.query('take', tuple, function(data) {
                var tuple = new Tuple();
                // Create a new tuple from the response
                tuple.fromJSON(data.response.tuples[0]);
                // Create answer true/false
                var answer = tuple.getField(0).getValue() == '1';
                if(typeof callback == 'function') callback.call(this, answer);
            }, {returning: 'false', randomize: 'false'});
        },

        /**
         * Returns the number of matching Tuple.
         * @param {Tuple} tuple The tuple template
         * @param {Function} callback The method to be called when a response arrives, receives the {Number} of found tuples
         * @param {Number} spaceId The spaceId of the space to delete from
         */
        count: function(tuple, callback, spaceId) {
            this.query('readAll', tuple, function(data) {
                var tuple = new Tuple();
                // Create a new tuple from the response
                tuple.fromJSON(data.response.tuples[0]);
                if(typeof callback == 'function') callback.call(this, tuple.getField(0).getValue());
            }, {returning: 'false'});
        },

        /**
         * Returns the current connected Space
         * @param {Function} callback The method to be called when a response arrives, receives a {Space}
         */
        getCurrentSpace: function(callback) {
            var self = this;
            this.tryTupleSpace(function() {
                if(typeof callback == 'function') callback.call(this, self.space);
            });
        },

        /**
         * Returns all existing spaces on the TupleSpace server
         * @param {Function} callback The method to be called when a response arrives, receives a {Space} array
         */
        getAllSpaces: function(callback) {
            var self = this;
            this.tryTupleSpace(function() {
                self.send({
                    'get-all-spaces': {}
                }, function(data) {
                    // Check if a tuple array was passed
                    if(data.response.tuples && data.response.tuples.length) {
                        var spaces = [];
                        for(var i = 0, il = data.response.tuples.length; i < il; i++) {
                            // Create a space from the tuple, created from response
                            var t = new Tuple();
                            t.fromJSON(data.response.tuples[i]);
                            spaces.push(new Space(
                                t.getField(0).getValue(),	// name
                                t.getField(1).getValue()	// id
                            ));
                        }
                        if(typeof callback == 'function') callback.call(this, spaces);
                    }
                })
            });
        },

        /**
         * Returns the space names of all existing spaces on the TupleSpace server
         * @param {Function} callback The method to be called when a response arrives, receives a {String} array
         */
        getSpaceNames: function(callback) {
            this.getAllSpaces(function(spaces) {
                var names = [];
                for(var i = 0, il = spaces.length; i < il; i++) names.push(spaces[i].getName());
                if(typeof callback == 'function') callback.call(this, names);
            });
        },

        getAllVersions: function(callback) {
            this.getVersions(function(versions) {
                if(typeof callback == 'function') callback.call(this, versions);
            });
        },

        getAllUserVersions: function(callback) {
            this.getVersions(function(versions) {
                if(typeof callback == 'function') callback.call(this, versions);
            }, {user: 'true'});
        },

        getCurrentVersion: function(callback) {
            this.getVersions(function(versions) {
                if(typeof callback == 'function') callback.call(this, versions[0]);
            }, {all: 'false'});
        },

        getCurrentUserVersion: function(callback) {
            this.getVersions(function(versions) {
                if(typeof callback == 'function') callback.call(this, versions);
            }, {all: 'false', user: 'true'});
        },

        switchToVersion: function(version, callback) {
            this.setVersion(function(version) {
                if(typeof callback == 'function') callback.call(this, version);
            }, {
                'old-versionsid': version.getVersion()
            });
        },

        createNewVersion: function(callback) {
            this.setVersion(function(version) {
                if(typeof callback == 'function') callback.call(this, version);
            }, {'new-version': 'true'});
        },

        beginTransaction: function(callback) {
            this.transaction(function(data) {
                if(typeof callback == 'function') callback.call(this, data);
            }, {type: 'begin'});
        },

        commitTransaction: function(callback) {
            this.transaction(function(data) {
                if(typeof callback == 'function') callback.call(this, data);
            }, {type: 'commit'});
        },

        abortTransaction: function(callback) {
            this.transaction(function(data) {
                if(typeof callback == 'function') callback.call(this, data);
            }, {type: 'abort'});
        },

        /**
         * Registers a callback {Function} to the connected space. Registered callback is invoked
         * if a {Tuple} matching the given template undergoes the given command {String}.
         *
         * @param {String } command The command for the event (write, delete, update, all)
         * @param {Tuple} tuple The tuple template
         * @param {Function} notifyCallback The function to be called if an registered event occurs,
         *          receives some properties plus the tuples as before and after attributes
         * @param {Function} callback The function to be called after a successful registration of
         *          the event, receives an registration id as a {Number}
         */
        eventRegister: function(command, tuple, notifyCallback, callback) {
            var self = this;
            if(tuple instanceof Tuple) {
                this.tryTupleSpace(function() {
                    self.send({
                        'event-register': {
                            'command': command,
                            'major': self.space.getVersion().getMajor(),
                            'minor': self.space.getVersion().getMinor(),
                            'version': self.space.getVersion().getVersion(),
                            'after': {
                                'tuple': tuple.toJSON()
                            },
                            'before': {}
                        }
                    }, function(data) {
                        // Check if a tuple array was passed
                        if(data.response.tuples && data.response.tuples.length) {
                            var tuple = new Tuple(),
                                callbackId = null;

                            // Create a new tuple from the response
                            tuple.fromJSON(data.response.tuples[0]);

                            // Callbacks
                            callbackId = tuple.getField(0).getValue();
                            // Save reference to notifyCallback
                            self.callbacks[callbackId] = notifyCallback;
                            // Call standard callback for passing callback id
                            if(typeof callback == 'function') callback.call(this, callbackId);
                        }
                    });
                });
            } else {
                throw new Error('Tuple must be an instance of Tuple');
            }
        },

        eventDeregister: function(callbackId, callback) {
            var self = this;
            this.tryTupleSpace(function() {
                self.send({
                    'event-deregister': {
                        'seq': callbackId
                    }
                }, function(data) {
                    if(typeof callback == 'function') callback.call(this, callbackId);
                });
            });
        },

        disconnect: function(callback) {
            var self = this;
            this.tryTupleSpace(function() {
                self.send({'disconnect': {}});
            });
        }
    }

});