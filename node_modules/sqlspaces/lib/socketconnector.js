/**
 * SQLSpaces Socket Connector
 *
 * User: wessel, giemza
 * Date: 09.02.12
 * Time: 20:19
 */

var net = require('net');

var Class = require('./class');

var Utils = require('./utils');

/**
 * Creates a new Connector
 * @class The Connector class is responsible for the communication between the javascript client and the tuplespace web socket.
 * @param options Options for the connector
 * @param {String} options.host The host to the web socket
 * @param {String} options.port The port used for the web socket
 * @param {String} options.endpoint The endpoint
 * @param {Boolean} options.json If the json parameter is true, every incoming and outgoing message will be
 *	parsed into JSON and gets an unique id to identify its response in the queue. If this parameter is false
 *	every message will be processed as string and gets no unique id. In this case the response to a message is
 *	always the directly next response from the server.
 * @param {Boolean} options.through If the through parameter is true, the responses from the server are
 *	passed directly to the onCallback method, stored in the options object
 */
module.exports = Class(/** @lends Connector */{
    /**
     * @constructs
     */
    'constructor': function(options) {

        /**
         * Stores the host of the socket
         * @private
         */
        this.host = options.host || 'localhost';

        /**
         * Stores the host of the socket
         * @private
         */
        this.port = options.port || 2525;

        /**
         * Set debug = false to avoid console messages
         * @private
         */
        this.debug = options.debug ||Â false;
        Utils.setDebugEnabled(this.debug);

        /**
         * Stores the ready state
         * @private
         */
        this.ready = false;

        /**
         * Stores the client socket object
         * @private
         */
        this.client;

        /**
         * Buffer for reading incoming data
         */
        this.buffer = '';

        /**
         * Stores the references of the callbacks awaiting an response from the server.
         * The callbacks have their unique server ids as index
         * @private
         */
        this.queue = [];

        /**
         * If the json parameter is true, every incoming and outgoing message will be
         *	parsed into JSON and gets an unique id to identify its response in the queue. If this parameter is false
         *	every message will be processed as string and gets no unique id. In this case the response to a message is
         *	always the directly next response from the server.
         * @private
         */
        this.json = (typeof options.json == 'undefined') ? true : options.json;

        /**
         * Stores the queueId
         * only used if json = false;
         * @private
         */
        this.queueId = 0;

        /**
         * If the through parameter is true, the responses from the server are passed directly to
         *	the onCallback method, stored in the options object
         * @private
         */
        this.through = (typeof options.through == 'undefined') ? false : options.through;

        /**
         * Stores the onCallback function
         */
        this.onCallback = options.onCallback;

        /**
         * Stores the onError function
         */
        this.onError = options.onError;

        // Check if the onCallback method is available in case of through = true
        if(this.through) {
            if(typeof options.onCallback !== 'undefined') this.onCallback = options.onCallback;
            else throw new Error('No onCallback method');
        }

        // Connect to the given location
        this.connect(
            this.location
        );
    },
    'private': {
        /**
         * Calls the callback when the web socket is connected
         * @param {Function} callback The Method to be called when the web socket is connected
         * @private
         */
        tryWebsocket: function(callback) {
            var self = this, interval, iterations = 0;

            if(this.ready == true) {
                callback.call();
            } else {
                interval = setInterval(function() {
                    iterations++;
                    Utils.log('Wait for Socket ' + self.host + ':' + self.port + ' (' + iterations + ')');
                    if(self.ready == true) {
                        clearInterval(interval);
                        callback.call();
                    } else if (iterations == 10) {
                        clearInterval(interval);
                        Utils.log('Socket wasn\'t able to react after 10 tries');
                    }
                }, 3000);
            }
        },

        /**
         * Connect to a location
         * @param {String} location The location of the web socket
         * @private
         */
        connect: function(location) {
            var self = this;

            Utils.log('Connecting to ' + this.host + ' on port ' + this.port);

            var socket = new net.Socket();
            
            this.client = socket.connect(this.port, this.host, function() {
                this.setEncoding('utf8');
                Utils.log('Connection established to ' + self.host + ' on port ' + self.port);
                self.ready = true;
            });


            this.client.on('data', function(data) {
                self.buffer = self.buffer + data;
                if (self.buffer.indexOf('\n') > 0) {
                    do {
                        var msg = self.buffer.substring(0, self.buffer.indexOf('\n'));
                        
                        // If the through parameter is true, the responses from the server are
                        // passed directly to the onCallback method
                        if(self.through == true) self.onCallback(msg);
                        else self.onMessage(msg);
                        
                        self.buffer = self.buffer.substring(self.buffer.indexOf('\n') + 1);
                    } while (self.buffer.indexOf('\n') > 0);
                }
            });

            this.client.on('end', function(msg) {
                self.onClose(msg);
            });

            this.client.on('error', function(e) {
                self.onError(e);
            });
        },

        /**
         * Called when the web socket was opened
         * @private
         */
        onOpen: function() {
            Utils.log('Connection established to ' + this.host + ' on port ' + this.port);
            this.ready = true;
        },

        /**
         * Called when a message arrives. Handles the responses from the server
         * @param {String} msg Message from the web socket
         * @private
         */
        onMessage: function(msg) {
            var message;
            Utils.log('Incomming Message on ' + this.host + ':' + this.port + ' => ' + msg);
            if(this.json == true) {
                message = JSON.parse(msg);

                // Handle response messages
                if(message.response) {
                    if(typeof this.queue[message.response.id] !== 'undefined') {
                        var id = message.response.id;
                        // Remove id from response object
                        delete message.response.id;
                        // Call callback in queue and delete
                        this.queue[id].call(this, message);
                        delete this.queue[id];
                    } else {
                        Utils.log('Could not assign response to an request in queue \n' + msg);
                    }
                } else if(message.callback) {
                    // Delete the id of the response
                    delete message.callback.id;
                    if(typeof this.onCallback == 'function') this.onCallback.call(this, message.callback);
                }
            } else {
                // Call callback in queue and delete
                this.queue[self.queueId].call(this, message);
                delete this.queue[self.queueId];
            }
        },

        /**
         * Called when the web socket was closed
         * @param {String} msg
         * @private
         */
        onClose: function(msg) {
            Utils.log('Socket ' + this.location + ' was closed \n' + msg);
            this.ready = false;
        },

        /**
         * Called when an error occurs
         * @param {Error} error
         * @private
         */
        onError: function(error) {
            Utils.log('Socket ' + this.location + ' error \n' + error);
        }
    },

    'public': {
        /**
         * Sends a message to the server
         * @param {String} message The message to be sent
         * @param {Function} callback The method to be called when the response arrives
         * @public
         */
        send: function(message, callback) {
            var self = this;

            this.tryWebsocket(function() {
                var request = {}, method, msg, uniqueId = Utils.getUniqueId();

                if(self.json == true) {
                    // Get the method
                    for (var prop in message) {
                        method = prop; break;
                    }
                    // Create request
                    request[method] = {id: uniqueId}

                    // Extend request with arguments
                    Utils.extend(request[method], message[method]);

                    // Add request to queue
                    self.queue[uniqueId] = callback;

                    // Send message via websocket
                    msg = JSON.stringify(request);

                } else {
                    // Add request to queue
                    self.queue[self.queueId++] = callback;
                    msg = message;
                }
                self.client.write(msg + '\r\n');
                Utils.log('Sent message to ' + self.host + ':' + self.port + ' => ' + msg);
            });
        },

        disconnect: function(callback) {
            if (callback) {
                this.client.on('end', callback);
            }
            this.client.end();
        }
    }
});