/**
 * SQLSpaces Websocket Connector
 *
 * User: wessel, giemza
 * Date: 09.02.12
 * Time: 20:19
 */

var Class = require('./class');

var Utils = require('./utils');

/**
 * Creates a new Connector
 * @class The Connector class is responsible for the communication between the javascript client and the tuplespace web socket.
 * @param options Options for the connector
 * @param {String} options.host The host to the web socket
 * @param {String} options.port The port used for the web socket
 * @param {String} options.endpoint The endpoint
 * @param {Boolean} options.json If the json parameter is true, every incoming and outgoing message will be
 *	parsed into JSON and gets an unique id to identify its response in the queue. If this parameter is false
 *	every message will be processed as string and gets no unique id. In this case the response to a message is
 *	always the directly next response from the server.
 * @param {Boolean} options.through If the through parameter is true, the responses from the server are
 *	passed directly to the onCallback method, stored in the options object
 */
module.exports = Class(/** @lends Connector */{
    /**
     * @constructs
     */
    'constructor': function(options) {

        /**
         * Stores the location of the web socket
         * @private
         */
        this.location = 'ws://' +
            (options.host || 'localhost') + ':' +
            (options.port || '8080') + '/' +
            (options.endpoint || 'ws-json');

        /**
         * Set debug = false to avoid console messages
         */
        this.debug = options.debug ||Â false;

        /**
         * Stores the ready state
         * @private
         */
        this.ready = false;

        /**
         * Stores the web socket object
         * @private
         */
        this.ws;

        /**
         * Stores the references of the callbacks awaiting an response from the server.
         * The callbacks have their unique server ids as index
         * @private
         */
        this.queue = [];

        /**
         * If the json parameter is true, every incoming and outgoing message will be
         *	parsed into JSON and gets an unique id to identify its response in the queue. If this parameter is false
         *	every message will be processed as string and gets no unique id. In this case the response to a message is
         *	always the directly next response from the server.
         * @private
         */
        this.json = (typeof options.json == 'undefined') ? true : options.json;

        /**
         * Stores the queueId
         * only used if json = false;
         * @private
         */
        this.queueId = 0;

        /**
         * If the through parameter is true, the responses from the server are passed directly to
         *	the onCallback method, stored in the options object
         * @private
         */
        this.through = (typeof options.through == 'undefined') ? false : options.through;

        /**
         * Stores the onCallback function
         */
        this.onCallback = options.onCallback;
        this.onErrorCallback = options.onError;

        // Check if the onCallback method is available in case of through = true
        if(this.through) {
            if(typeof options.onCallback !== 'undefined') this.onCallback = options.onCallback;
            else throw new Error('No onCallback method');
        }

        // Connect to the given location
        this.connect(
            this.location
        );
    },
    'private': {
        /**
         * Calls the callback when the web socket is connected
         * @param {Function} callback The Method to be called when the web socket is connected
         * @private
         */
        tryWebsocket: function(callback) {
            var self = this, interval, iterations = 0;

            if(this.ready == true) {
                callback.call();
            } else {
                interval = setInterval(function() {
                    iterations++;
                    Utils.log('Wait for websocket ' + self.location + ' (' + iterations + ')');
                    if(self.ready == true) {
                        clearInterval(interval);
                        callback.call();
                    } else if (iterations == 10) {
                        clearInterval(interval);
                        Utils.log('Websocket wasn\'t able to react after 10 tries');
                    }
                }, 100);
            }
        },

        /**
         * Connect to a location
         * @param {String} location The location of the web socket
         * @private
         */
        connect: function(location) {
            var self = this;

            Utils.log('Connecting to ' + self.location);

            // Firefox websocket
            if (typeof WebSocket == 'undefined') this.ws = new MozWebSocket(self.location);
            else this.ws = new WebSocket(self.location);

            this.ws.onopen = function() {
                self.onOpen();
            }

            this.ws.onmessage = function(msg) {
                // If the through parameter is true, the responses from the server are
                // passed directly to the onCallback method
                if(self.through == true) self.onCallback(msg);
                else self.onMessage(msg);
            }

            this.ws.onclose = function(msg) {
                self.onClose(msg);
            }

            this.ws.onerror = function(e) {
                self.onError(e);
            }
        },

        /**
         * Called when the web socket was opened
         * @private
         */
        onOpen: function() {
            Utils.log('Connection established to ' + this.location);
            this.ready = true;
        },

        /**
         * Called when a message arrives. Handles the responses from the server
         * @param {String} msg Message from the web socket
         * @private
         */
        onMessage: function(msg) {
            var message;
            Utils.log('Incomming Message on ' + this.location + ' \n' + msg.data);
            if(this.json == true) {

                message = JSON.parse(msg.data);

                // Handle response messages
                if(message.response) {
                    if(typeof this.queue[message.response.id] !== 'undefined') {
                        var id = message.response.id;

							var cb = this.queue[id];
                        delete this.queue[id];

							// Call callback in queue and delete
							cb.call(this, message);

                    } else {
                        Utils.log('Could not assign response to an request in queue \n' + msg);
                    }
                } else if(message.callback) {
                    if(typeof this.onCallback == 'function') this.onCallback.call(this, message.callback);
                }
            } else {
                // Call callback in queue and delete
                this.queue[self.queueId].call(this, message);
                delete this.queue[self.queueId];
            }
        },

        /**
         * Called when the web socket was closed
         * @param {String} msg
         * @private
         */
        onClose: function(msg) {
            Utils.log('Websocket ' + this.location + ' was closed \n' + msg);
            this.ready = false;
            if(typeof this.onErrorCallback == 'function') this.onErrorCallback.call(this, msg);
        },

        /**
         * Called when an error occurs
         * @param {Error} error
         * @private
         */
        onError: function(error) {
            Utils.log('Websocket ' + this.location + ' error \n' + error);
            if(typeof this.onErrorCallback == 'function') this.onErrorCallback.call(this, error);
        }
    },

    'public': {
        /**
         * Sends a message to the server
         * @param {String} message The message to be sent
         * @param {Function} callback The method to be called when the response arrives
         * @public
         */
        send: function(message, callback, requestId) {
            var self = this;

            this.tryWebsocket(function() {
                var request = {}, method, msg, uniqueId = requestId || Utils.getUniqueId();

                if(self.json == true) {
                    // Get the method
                    for (var prop in message) {
                        method = prop; break;
                    }

                    // Prevent close event
                    if(method == 'disconnect') {
                        self.onClose = function () {};
                        self.onError = function() {};
                    }

                    // Create request
                    request[method] = {id: uniqueId}

                    // Extend request with arguments
                    Utils.extend(request[method], message[method]);

                    // Add request to queue
                    self.queue[uniqueId] = callback;

                    // Send message via websocket
                    msg = JSON.stringify(request);

                } else {
                    // Add request to queue
                    self.queue[self.queueId++] = callback;
                    msg = message;
                }
                self.ws.send(msg);
                Utils.log('Send message \n' + msg);
            });
        },

        disconnect: function() {
            this.onClose = function () {};
            this.onError = function () {};
            this.ws.close();
        }
    }
});